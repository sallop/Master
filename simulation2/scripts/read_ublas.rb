#!/usr/bin/ruby
require 'matrix'
require 'scanf'

def make_ublas_example(m,n)
  return "[#{m},#{n}](" << (1..m).collect{|r|
    '(' << (1..n).collect{|c|
      sprintf('%8.4f',rand)
    }.join(',') << ')'
  }.join(',') << ')'
end

D = 4
P = 4
# lines = (1..8).collect{|t|
#   "#{t}\t#{make_ublas_example(D,P)}"
# }.join("\n")

# for line in lines
#   puts line
# end

# lines =<<EOS
# 35859	[4,4]((0,-2.68202,-2.66056,-2.66599),(-2.68202,0,-0.47485,-1.05019),(-2.66056,-0.47485,0,-1.58683),(-2.66599,-1.05019,-1.58683,0))
# 35860	[4,4]((0,-2.68203,-2.66056,-2.666),(-2.68203,0,-0.474851,-1.05019),(-2.66056,-0.474851,0,-1.58683),(-2.666,-1.05019,-1.58683,0))
# 35861	[4,4]((0,-2.68204,-2.66057,-2.666),(-2.68204,0,-0.474853,-1.05019),(-2.66057,-0.474853,0,-1.58683),(-2.666,-1.05019,-1.58683,0))
# 35862	[4,4]((0,-2.68204,-2.66058,-2.66601),(-2.68204,0,-0.474855,-1.0502),(-2.66058,-0.474855,0,-1.58684),(-2.66601,-1.0502,-1.58684,0))
# 35863	[4,4]((0,-2.68205,-2.66058,-2.66602),(-2.68205,0,-0.474856,-1.0502),(-2.66058,-0.474856,0,-1.58684),(-2.66602,-1.0502,-1.58684,0))
# 35864	[4,4]((0,-2.68206,-2.66059,-2.66602),(-2.68206,0,-0.474858,-1.0502),(-2.66059,-0.474858,0,-1.58685),(-2.66602,-1.0502,-1.58685,0))
# 35865	[4,4]((0,-2.68206,-2.6606,-2.66603),(-2.68206,0,-0.474859,-1.0502),(-2.6606,-0.474859,0,-1.58685),(-2.66603,-1.0502,-1.58685,0))
# 35866	[4,4]((0,-2.68207,-2.66061,-2.66604),(-2.68207,0,-0.47486,-1.05021),(-2.66061,-0.47486,0,-1.58685),(-2.66604,-1.05021,-1.58685,0))
# 35867	[4,4]((0,-2.68208,-2.66061,-2.66604),(-2.68208,0,-0.474862,-1.05021),(-2.66061,-0.474862,0,-1.58686),(-2.66604,-1.05021,-1.58686,0))
# 35868	[4,4]((0,-2.68208,-2.66062,-2.66605),(-2.68208,0,-0.474863,-1.05021),(-2.66062,-0.474863,0,-1.58686),(-2.66605,-1.05021,-1.58686,0))
# EOS


# lines =<<EOS
# 49990	[16](0.05925,0.061,0.0655,0.06525,0.0585,0.05725,0.06375,0.0615,0.063,0.054,0.0555,0.062,0.0685,0.0665,0.0675,0.071)
# 49991	[16](0.061,0.05925,0.064,0.05875,0.0595,0.06575,0.062,0.06025,0.0625,0.06125,0.0675,0.0655,0.0635,0.068,0.05875,0.0625)
# 49992	[16](0.06025,0.05925,0.064,0.059,0.058,0.0615,0.0645,0.0695,0.06425,0.07,0.06375,0.0605,0.0525,0.06575,0.06525,0.062)
# 49993	[16](0.0625,0.061,0.06275,0.06075,0.06375,0.05725,0.06175,0.0645,0.06525,0.06,0.0645,0.05475,0.06575,0.067,0.062,0.0665)
# 49994	[16](0.06,0.0615,0.0605,0.06075,0.06,0.05975,0.0595,0.0605,0.067,0.05925,0.06825,0.06,0.07125,0.065,0.05975,0.067)
# 49995	[16](0.0605,0.05775,0.0645,0.064,0.06125,0.061,0.06,0.06675,0.06275,0.06625,0.06125,0.06225,0.06575,0.061,0.061,0.064)
# 49996	[16](0.0625,0.06525,0.0655,0.061,0.06,0.0585,0.07175,0.056,0.059,0.0585,0.06175,0.067,0.06375,0.066,0.05975,0.06375)
# 49997	[16](0.0655,0.0595,0.068,0.0605,0.0645,0.0635,0.063,0.06225,0.065,0.0625,0.06075,0.06725,0.06325,0.05675,0.059,0.05875)
# 49998	[16](0.06375,0.06475,0.059,0.065,0.05775,0.0605,0.06175,0.06475,0.0665,0.0625,0.05825,0.06175,0.067,0.0585,0.06475,0.0635)
# 49999	[16](0.06425,0.06575,0.0665,0.06025,0.0655,0.065,0.06575,0.059,0.066,0.06075,0.05875,0.0585,0.0555,0.06425,0.06275,0.0615)
# EOS

# lines = lines.split("\n")

def read_ublas_matrix(line)
  /^(\d+)\s+\[(\d+),(\d+)\]\((.+)\)/ =~ line
  t    = $1
  row  = $2.to_i
  col  = $3.to_i
  elem = $4                     # matrix literal strings

  fmt = (1..row).collect{|r|
    '(' + (1..col).collect{|c| "%f"}.join(",") + ')'
  }.join(",")

  peeled = elem.scanf(fmt)
  mat = (0..row-1).collect{|r|
    p0 = r*col
    p1 = r*col + col
    peeled[p0..(p1-1)]
  }
  return t, mat
end

def read_ublas_vector(line)
  /^(\d+)\s+\[(\d+)\]\((.+)\)/ =~ line
  t    = $1
  size = $2.to_i
  elem = $3                     # vector literal strings
  # fmt = (1..size).collect{|i|
  #     '(' + (1..col).collect{|c| "%f"}.join(",") + ')'
  #   }.join(",")
  peeled = elem.split(",")
  vector = peeled.collect{|s| s.to_f}
  return t, vector
end

# for line in lines
#   t, vec = read_ublas_vector(line)
#   printf("%d\t",t)
#   vec.each{|e| printf("%f ",e)}
#   printf("\n")
# end

fname_mat = ARGV[0]
fname_vec = ARGV[1]

# prefix = 'peeled_'
# oname_mat = prefix+fname_mat
# oname_vec = prefix+fname_vec
# puts "matrix peel start"
# fo = open(oname_mat,"w")

oname_mat = STDOUT
oname_vec = STDOUT

#fo = open(oname_mat,"w")
fo = STDOUT
open(fname_mat, 'r') do |fr|
  while line = fr.gets do
    t, mat = read_ublas_matrix(line)
    printf(fo,"%d\t",t)
    mat.each{|r| r.each{|e| printf(fo,"%f ",e)}}
    printf(fo,"\n")
  end
end
#fo.close()

#puts "matrix peel end"

#puts "vector peel start"
#fo = open(oname_vec,"w")


open(fname_vec, 'r') do |fr|
  while line = fr.gets do
    t, vec = read_ublas_vector(line)
    printf(fo,"%d\t",t)
    vec.each{|e| printf(fo,"%f ",e)}
    printf(fo,"\n")
  end
end
fo.close()
#puts "vector peel end"

# for line in lines
#   t,mat = read_ublas_data(line)
#   printf("%d\t",t)
#   mat.each{|r| r.each{|e| printf("%f ",e)}}
#   printf("\n")
# end

#   /^(\d+)/ =~ line
#   t = $1
#   /\[(\d+),(\d)\]\((.+)\)/ =~ line
#   row,col,elem = $1.to_i,$2.to_i,$3

#   fmt = (1..row).collect{|r|
#     '('+(1..col).collect{|c|"%f"}.join(",")+')'
#   }.join(",")
#   #  p fmt
#   peeled = elem.scanf(fmt)
#   #elem2.each_with_index{|v,i| puts "#{i}->#{v}"}

#   mat = (0..row-1).collect{|r|
#     p0, p1 = r*col, r*col + col
#     peeled[p0..(p1-1)]
#   }

#   printf("%d\t",t)
#   mat.each{|mr|
#     mr.each{|e| printf("%8.4f ", e)}
#   }
#   printf("\n")


#   puts t
#   for mr in mat
#     mr.each{|e| printf("%8.6f\t",e)}
#     printf("\n")
#   end

